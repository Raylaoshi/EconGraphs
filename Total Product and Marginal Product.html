<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Production Model</title>
    <style>
        :root {
            --tp-color: #00695c;
            --mp-color: #c62828;
            --tangent-color: #c62828;
            --bg-color: #f4f7f6;
            --box-bg: #ffffff;
        }

        body {
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            margin: 0;
            /* Prevents accidental pull-to-refresh on mobile while dragging */
            touch-action: none;
        }

        h2 { margin: 10px 0 5px 0; color: #1a237e; font-size: 1.4em; text-align: center; }
        p.subtitle { margin-top: 0; color: #546e7a; font-size: 0.9em; margin-bottom: 15px; text-align: center; max-width: 600px; padding: 0 10px;}

        /* RESPONSIVE CONTAINER */
        .canvas-container {
            position: relative;
            background: #fff;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            border-radius: 8px;
            width: 95vw; /* Fills most of the mobile screen width */
            max-width: 750px; /* Limits size on large desktops */
            aspect-ratio: 1 / 1.05; /* Keeps a consistent shape regardless of size */
            user-select: none;
            cursor: ew-resize;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* The Explanation Box - Responsive Positioned */
        #smart-tooltip {
            position: absolute;
            /* Y-position is calculated in JS based on percentage of container height */
            transform: translate(-50%, -50%); 
            width: 60%; /* Scales with the container */
            min-width: 180px;
            max-width: 240px;
            background: var(--box-bg);
            border: 1px solid #ddd;
            border-top: 3px solid var(--tp-color);
            border-bottom: 3px solid var(--mp-color);
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            padding: 8px 12px;
            z-index: 10; 
            pointer-events: none; 
            text-align: center;
        }

        .stat-grid {
            display: flex;
            justify-content: space-around;
            margin-bottom: 5px;
            font-family: "Menlo", monospace;
            font-size: 12px;
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 3px;
        }
        
        .stat-val { font-weight: bold; }
        .note-title { font-weight: 800; margin-bottom: 2px; display: block; color: #1a237e; font-size: 11px; text-transform: uppercase; }
        .note-body { color: #37474f; font-size: 11px; line-height: 1.3; }
        .highlight-text { background: rgba(255, 235, 59, 0.4); padding: 0 3px; border-radius: 2px; color: #000; }

        @media (max-width: 400px) {
            h2 { font-size: 1.1em; }
            .note-title { font-size: 10px; }
            .note-body { font-size: 10px; }
        }
    </style>
</head>
<body>

    <h2>Short-Run Production Function</h2>
    <p class="subtitle">Drag anywhere. The model scales to fit your device.</p>

    <div class="canvas-container" id="container">
        <canvas id="mainCanvas"></canvas>

        <div id="smart-tooltip">
            <div class="stat-grid">
                <span>Labor: <span class="stat-val" id="disp-l">0</span></span>
            </div>
            <span class="note-title" id="note-title">Phase</span>
            <div class="note-body" id="note-body">Explanation...</div>
        </div>
    </div>

<script>
    const CONFIG = {
        minL: 0,
        maxL: 10,
        funcTP: (L) => -Math.pow(L, 3) + 12 * Math.pow(L, 2),
        funcMP: (L) => -3 * Math.pow(L, 2) + 24 * L,
        inflectionPoint: 4, 
        maxTotalPoint: 8,
        colors: {
            tp: '#00695c',
            mp: '#c62828',
            tangent: '#c62828',
            grid: '#e0e0e0',
            axis: '#263238',
            zoneInc: '#e8f5e9', 
            zoneDim: '#fff8e1'
        },
        scales: { maxTP_Y: 300, maxMP_Y: 60, minMP_Y: -70 }
    };

    let state = { L: 3.0, isDragging: false };
    let dynamicLayout = {};

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('smart-tooltip');
    const container = document.getElementById('container');

    // DYNAMICALLY CALCULATE DIMENSIONS BASED ON CURRENT SCREEN SIZE
    function updateLayoutMetrics() {
        const rect = container.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;

        dynamicLayout = {
            width: w,
            height: h,
            paddingLeft: w * 0.1,  // Proportional padding
            paddingRight: w * 0.08,
            topGraphY: h * 0.05,
            topGraphH: h * 0.38,
            botGraphY: h * 0.62,
            botGraphH: h * 0.32,
            tooltipY: h * 0.51  // Position box at 51% height
        };

        tooltip.style.top = dynamicLayout.tooltipY + "px";
        
        // Handle High DPI scaling
        const dpr = window.devicePixelRatio || 1;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset
        ctx.scale(dpr, dpr);
    }

    const toX = (L) => {
        const usableW = dynamicLayout.width - dynamicLayout.paddingLeft - dynamicLayout.paddingRight;
        return dynamicLayout.paddingLeft + (L / CONFIG.maxL) * usableW;
    };
    const fromX = (px) => {
        const usableW = dynamicLayout.width - dynamicLayout.paddingLeft - dynamicLayout.paddingRight;
        let val = ((px - dynamicLayout.paddingLeft) / usableW) * CONFIG.maxL;
        return Math.max(0, Math.min(CONFIG.maxL, val));
    };
    const toY = (val, graphTop, graphHeight, maxVal, minVal = 0) => {
        const range = maxVal - minVal;
        const normalized = (val - minVal) / range;
        return (graphTop + graphHeight) - (normalized * graphHeight);
    };

    function drawZones() {
        const left = dynamicLayout.paddingLeft;
        const right = dynamicLayout.width - dynamicLayout.paddingRight;
        const xInflect = toX(CONFIG.inflectionPoint);

        const paint = (y, h) => {
            ctx.fillStyle = CONFIG.colors.zoneInc;
            ctx.fillRect(left, y, xInflect - left, h);
            ctx.fillStyle = CONFIG.colors.zoneDim;
            ctx.fillRect(xInflect, y, right - xInflect, h);
        };
        paint(dynamicLayout.topGraphY, dynamicLayout.topGraphH);
        paint(dynamicLayout.botGraphY, dynamicLayout.botGraphH);
    }

    function drawGrid(graphTop, graphHeight, maxVal, minVal, stepY, isBottom) {
        const left = dynamicLayout.paddingLeft;
        const right = dynamicLayout.width - dynamicLayout.paddingRight;
        const bottom = graphTop + graphHeight;

        ctx.lineWidth = 1;
        ctx.font = dynamicLayout.width < 400 ? "9px Arial" : "11px Arial";
        
        // Y Axis
        ctx.textAlign = "right"; ctx.textBaseline = "middle";
        for(let v = minVal; v <= maxVal; v += stepY) {
            if(v === 0 && minVal !== 0) continue; 
            const y = toY(v, graphTop, graphHeight, maxVal, minVal);
            ctx.beginPath(); ctx.strokeStyle = CONFIG.colors.grid; 
            ctx.moveTo(left, y); ctx.lineTo(right, y); ctx.stroke();
            ctx.fillStyle = "#78909c";
            ctx.fillText(v, left - 5, y);
        }

        // X Axis
        ctx.textAlign = "center"; ctx.textBaseline = "top";
        for(let l = 1; l <= CONFIG.maxL; l++) {
            const x = toX(l);
            ctx.beginPath(); ctx.strokeStyle = CONFIG.colors.grid;
            ctx.moveTo(x, graphTop); ctx.lineTo(x, bottom); ctx.stroke();
            ctx.fillStyle = "#78909c";
            ctx.fillText(l, x, bottom + 5);
        }
    }

    function drawLabels() {
        const left = dynamicLayout.paddingLeft;
        const right = dynamicLayout.width - dynamicLayout.paddingRight;
        const xInflect = toX(CONFIG.inflectionPoint);
        ctx.font = dynamicLayout.width < 450 ? "bold 9px sans-serif" : "bold 11px sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        const txt1 = "INCREASING RETURNS", txt2 = "DIMINISHING RETURNS";
        ctx.fillText(txt1, (left + xInflect)/2, dynamicLayout.topGraphY + 15);
        ctx.fillText(txt2, (xInflect + right)/2, dynamicLayout.topGraphY + 15);
        ctx.fillText(txt1, (left + xInflect)/2, dynamicLayout.botGraphY + 15);
        ctx.fillText(txt2, (xInflect + right)/2, dynamicLayout.botGraphY + 15);
    }

    function drawAxes(graphTop, graphHeight, maxVal, minVal, title) {
        const left = dynamicLayout.paddingLeft;
        const right = dynamicLayout.width - dynamicLayout.paddingRight;
        const bottom = graphTop + graphHeight;
        const yZero = toY(0, graphTop, graphHeight, maxVal, minVal);

        ctx.beginPath(); ctx.strokeStyle = CONFIG.colors.axis; ctx.lineWidth = 1.5;
        ctx.moveTo(left, graphTop); ctx.lineTo(left, bottom);
        ctx.moveTo(left, yZero); ctx.lineTo(right, yZero);
        ctx.stroke();

        ctx.fillStyle = "#263238"; ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "left"; ctx.fillText(title, left, graphTop - 10);
        
        ctx.save();
        ctx.translate(left - (dynamicLayout.width * 0.07), graphTop + graphHeight/2);
        ctx.rotate(-Math.PI/2); ctx.textAlign = "center"; ctx.font = "bold 10px sans-serif";
        ctx.fillText("Output", 0, 0);
        ctx.restore();

        ctx.textAlign = "right"; ctx.fillText("Labor", right, bottom + 20);
    }

    function drawCurve(func, graphTop, graphHeight, maxVal, minVal, color) {
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2.5; ctx.lineJoin = 'round';
        const left = dynamicLayout.paddingLeft, right = dynamicLayout.width - dynamicLayout.paddingRight;
        for (let px = left; px <= right; px+=1) {
            const l = fromX(px);
            const py = toY(func(l), graphTop, graphHeight, maxVal, minVal);
            if (py >= graphTop && py <= graphTop + graphHeight) {
                if(px === left) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
        }
        ctx.stroke();
    }

    function drawTangentAndLabel(L, tpVal, slope) {
        const len = 1.6; 
        const x1 = L - len, x2 = L + len;
        const y1 = slope*(x1-L) + tpVal, y2 = slope*(x2-L) + tpVal;
        const px1 = toX(x1), py1 = toY(y1, dynamicLayout.topGraphY, dynamicLayout.topGraphH, CONFIG.scales.maxTP_Y);
        const px2 = toX(x2), py2 = toY(y2, dynamicLayout.topGraphY, dynamicLayout.topGraphH, CONFIG.scales.maxTP_Y);

        ctx.save();
        ctx.beginPath();
        ctx.rect(dynamicLayout.paddingLeft, dynamicLayout.topGraphY, dynamicLayout.width - dynamicLayout.paddingLeft - dynamicLayout.paddingRight, dynamicLayout.topGraphH);
        ctx.clip();
        ctx.beginPath(); ctx.strokeStyle = CONFIG.colors.tangent; ctx.lineWidth = 2; 
        ctx.moveTo(px1, py1); ctx.lineTo(px2, py2); ctx.stroke();
        ctx.restore();

        const pointX = toX(L), pointY = toY(tpVal, dynamicLayout.topGraphY, dynamicLayout.topGraphH, CONFIG.scales.maxTP_Y);
        const text = `Slope = MP = ${slope.toFixed(1)}`;
        ctx.font = "bold 10px monospace";
        const textWidth = ctx.measureText(text).width;
        
        let lx = pointX - 15;
        ctx.textAlign = "right";
        if (lx - textWidth < dynamicLayout.paddingLeft) {
            lx = pointX + 15;
            ctx.textAlign = "left";
        }
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillRect(ctx.textAlign === "right" ? lx - textWidth - 4 : lx - 4, pointY - 18, textWidth + 8, 14);
        ctx.fillStyle = CONFIG.colors.tangent;
        ctx.textBaseline = "middle";
        ctx.fillText(text, ctx.textAlign === "right" ? lx - 2 : lx + 2, pointY - 11);
    }

    function drawIndicator(L) {
        const x = toX(L);
        ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.strokeStyle = "#90a4ae"; ctx.lineWidth = 1;
        ctx.moveTo(x, dynamicLayout.topGraphY); ctx.lineTo(x, dynamicLayout.botGraphY + dynamicLayout.botGraphH); ctx.stroke();
        ctx.setLineDash([]);
    }

    function drawPointAndVal(L, val, gTop, gH, gMax, gMin, color, prefix) {
        const x = toX(L), y = toY(val, gTop, gH, gMax, gMin);
        if(y < gTop || y > gTop + gH) return;
        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI * 2); ctx.fillStyle = "#fff"; ctx.fill(); ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();
        const text = `${prefix}: ${val.toFixed(0)}`;
        ctx.font = "bold 10px monospace";
        const boxW = ctx.measureText(text).width + 8;
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.fillRect(x + 10, y - 16, boxW, 14);
        ctx.fillStyle = color; ctx.textAlign = "left"; ctx.fillText(text, x + 14, y - 9);
    }

    function updateDOM(L) {
        tooltip.style.left = toX(L) + "px";
        document.getElementById('disp-l').innerText = L.toFixed(1);
        const titleEl = document.getElementById('note-title'), bodyEl = document.getElementById('note-body');
        if (L < 3.9) {
            titleEl.innerText = "Increasing Marginal Returns";
            bodyEl.innerHTML = `Total Product is <span class="highlight-text">convex</span>.<br><b>Marginal Product</b> is rising.`;
        } else if (L >= 3.9 && L <= 4.1) {
            titleEl.innerText = "Inflection Point";
            bodyEl.innerHTML = `Maximum steepness.<br><b>Marginal Product</b> is maximized.`;
        } else if (L > 4.1 && L < 7.9) {
            titleEl.innerText = "Diminishing Returns";
            bodyEl.innerHTML = `Total Product is <span class="highlight-text">concave</span>.<br><b>Marginal Product</b> is falling.`;
        } else if (L >= 7.9 && L <= 8.1) {
            titleEl.innerText = "Maximum Total Product";
            bodyEl.innerHTML = `Slope = 0.<br><b>Marginal Product is Zero</b>.`;
        } else {
            titleEl.innerText = "Negative Returns";
            bodyEl.innerHTML = `Slope is negative.<br><b>Marginal Product</b> is negative.`;
        }
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const L = state.L, TP = CONFIG.funcTP(L), MP = CONFIG.funcMP(L);
        drawZones();
        drawGrid(dynamicLayout.topGraphY, dynamicLayout.topGraphH, CONFIG.scales.maxTP_Y, 0, 50, false);
        drawGrid(dynamicLayout.botGraphY, dynamicLayout.botGraphH, CONFIG.scales.maxMP_Y, CONFIG.scales.minMP_Y, 20, true);
        drawLabels();
        drawIndicator(L);
        drawAxes(dynamicLayout.topGraphY, dynamicLayout.topGraphH, CONFIG.scales.maxTP_Y, 0, "Total Product");
        drawAxes(dynamicLayout.botGraphY, dynamicLayout.botGraphH, CONFIG.scales.maxMP_Y, CONFIG.scales.minMP_Y, "Marginal Product");
        drawCurve(CONFIG.funcTP, dynamicLayout.topGraphY, dynamicLayout.topGraphH, CONFIG.scales.maxTP_Y, 0, CONFIG.colors.tp);
        drawTangentAndLabel(L, TP, MP);
        drawCurve(CONFIG.funcMP, dynamicLayout.botGraphY, dynamicLayout.botGraphH, CONFIG.scales.maxMP_Y, CONFIG.scales.minMP_Y, CONFIG.colors.mp);
        drawPointAndVal(L, TP, dynamicLayout.topGraphY, dynamicLayout.topGraphH, CONFIG.scales.maxTP_Y, 0, CONFIG.colors.tp, "Total Product");
        drawPointAndVal(L, MP, dynamicLayout.botGraphY, dynamicLayout.botGraphH, CONFIG.scales.maxMP_Y, CONFIG.scales.minMP_Y, CONFIG.colors.mp, "Marginal Product");
        updateDOM(L);
    }

    function handleInput(e) {
        const rect = container.getBoundingClientRect();
        const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
        state.L = fromX(clientX - rect.left);
        if (Math.abs(state.L - Math.round(state.L)) < 0.2) state.L = Math.round(state.L);
        render();
    }

    container.addEventListener('mousedown', (e) => { state.isDragging = true; handleInput(e); });
    window.addEventListener('mousemove', (e) => { if(state.isDragging) handleInput(e); });
    window.addEventListener('mouseup', () => state.isDragging = false);
    container.addEventListener('touchstart', (e) => { state.isDragging = true; handleInput(e); e.preventDefault(); }, {passive: false});
    window.addEventListener('touchmove', (e) => { if(state.isDragging) { handleInput(e); e.preventDefault(); } }, {passive: false});
    window.addEventListener('touchend', () => state.isDragging = false);

    window.addEventListener('resize', () => { updateLayoutMetrics(); render(); });

    updateLayoutMetrics();
    render();
</script>
</body>
</html>
